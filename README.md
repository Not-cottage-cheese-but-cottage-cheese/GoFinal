# Go

Решение задач трека Go команды "Не творог, а творог"

- [10-30](#10-30)
- [40](#40)


# Общее руководство по запуску
Для запуска потребуется `go1.18`

### Запуск без сборки:
```bash
go run path/to/main.go arg1 arg2 ... argN
```

### Запуск со сброкой:
```bash
go build .
```
C последующим запуском бинарного файла

main.go файлы располагаются по пути 
```bash
/cmd/{TASK}/main.go
```
например 
```bash
/cmd/30/main.go
```

# 10-30
Для запуска скриптов необходим один аргумент - путь до файла с задачами:
```bash
go run ./cmd/30/main.go path/to/file
```
Простенький файл можно найти в папке *tasks*

# 40
Реализован простой сервер на fiber. По умолчанию прослушивает 5000 порт.

## Описание методов

- /add - POST метод, принимающий в качестве query-параметра *mod* два возможных значения - sync и async (для синхронных и асинхронных задач соответственно). В теле передается время задачи в формате time.Duration простым текстом text/plain. Например:
```bash
query:
    localhost:5000/add?mod=async
    localhost:5000/add?mod=sync
body:
    3s
```
При варианте **async** с сервера придет ответ **task added**, при варианте **sync** (после выполнения задачи) **task done**.

- /time - GET метод, возвращающий строкой в формате time.Duration время всех задач в очереди (не считая исполняемой в данный момент задачи)

- /schedule - GET метод, возвращающий оставшиеся задачи в формате JSON (не считая исполняемой в данный момент задачи)

```json
[
    {
        "duration": "30s"
    },
    {
        "duration": "40s"
    }
]
```

# Описание задач

## 10
Напишите программу, которая читает входной файл и выполняет все задачи последовательно. Логируйте начало и конец выполнения каждой задачи. Само выполнение задачи — это time.Sleep(time.Duration). Сохраните это решение в отдельный файл.

## 20
Напишите программу, которая читает входной файл и выполняет все задачи параллельно. Логируйте начало и конец выполнения каждой задачи. Само выполнение задачи — это time.Sleep(time.Duration). Запустите каждую задачу в отдельной горутине. Сохраните это решение в отдельный файл.

## 30
Напишите программу, ограничивающую количество процессоров, на которых выполняются задачи из входного файла, числом из stdin. При освобождении работы на процессоре моментально должна начинать исполняться следующая в списке из файла задача. Используйте синхронизацию горутин на каналах.

## 40
Напишите свой веб-сервер, принимающий на вход задачу, но обрабатывающий параллельно поданные задачи последовательно, как будто на одном процессоре.

add-метод POST:

Добавляет новую задачу с длительностью timeDuration в список задач, с параметром sync/async:

sync — держим HTTP-коннект и возвращаем ответ только после выполнения всех задач в очереди, а также выполнения самой задачи, которая держит коннект;
async POST — добавляем задачу в очередь и сразу отключаемся.
schedule-метод GET возвращает массив актуальных задач, стоящих в очереди на выполнение, в формате JSON.

time-метод GET возвращает оставшееся время на выполнение всех находящихся в очереди задач.

Помимо веб-сервера, напишите скрипт на Go, тестирующий ваш веб-сервер и проверяющий все основные юзкейсы. (Нужно в несколько горутин ддосить ваш веб-сервер post-запросами и проверять, совпадает ли таймер с теоретическим временем, рассчитанным на клиенте.)

## 50
В работе мы часто используем формат protobuf для спецификации хранения наших данных.

developers.google.com/protocol-buffers/docs/encoding

developers.google.com/protocol-buffers/docs/reference/proto3-spec

Вам дан набор proto-файлов с описанием структур данных. Скачайте их здесь (https://cloud.mail.ru/public/d7PN/PetsQmq47).

У вас есть набор бинарных данных, каждый файл соответствует ровно одному proto-файлу по структуре.

Напишите решение, которое сопоставит, какому из proto-файлов соответствует бинарный файл. Расшифруйте бинарный файл. Выведите значения соответствующих полей после расшифровки (названия полей берите из proto-файла).
